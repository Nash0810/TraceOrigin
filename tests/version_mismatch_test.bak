package tests

import (
	"encoding/json"
	"io/ioutil"
	"path/filepath"
	"testing"
	"time"

	"github.com/Nash0810/TraceOrigin/pkg/correlator"
	"github.com/Nash0810/TraceOrigin/pkg/manifest"
)

// VersionMismatchScenario represents an attack scenario
type VersionMismatchScenario struct {
	Scenario        string      `json:"scenario"`
	Description     string      `json:"description"`
	Manifest        interface{} `json:"manifest"`
	Trace           []interface{} `json:"trace"`
	ExpectedResult  interface{} `json:"expected_result"`
}

// LoadAttackScenarios loads attack scenarios from JSON
func LoadAttackScenarios(t *testing.T) []VersionMismatchScenario {
	scenarioPath := filepath.Join("scenarios", "attack_scenarios.json")
	data, err := ioutil.ReadFile(scenarioPath)
	if err != nil {
		t.Fatalf("Failed to load attack scenarios: %v", err)
	}

	var scenarios []VersionMismatchScenario
	if err := json.Unmarshal(data, &scenarios); err != nil {
		t.Fatalf("Failed to parse attack scenarios: %v", err)
	}

	return scenarios
}

// TestVersionDowngradeDetection validates detection of version downgrade attacks
func TestVersionDowngradeDetection(t *testing.T) {
	engine := correlator.NewEngine()

	// Declared: urllib3@1.26.12
	engine.AddDeclaredPackage(&manifest.DeclaredPackage{
		Name:            "urllib3",
		DeclaredVersion: "1.26.12",
		PackageManager:  "python",
		ConstraintType:  "==",
	})

	// Observed: urllib3@1.26.5 (downgrade to vulnerable version)
	engine.AddHTTPEvent(&correlator.HTTPEvent{
		URL:       "https://files.pythonhosted.org/packages/urllib3-1.26.5-py2.py3-none-any.whl",
		Method:    "GET",
		Status:    200,
		Timestamp: time.Now().Format(time.RFC3339),
	})

	chains := engine.BuildChains()
	mismatches := engine.DetectVersionMismatches(chains)

	if len(mismatches) == 0 {
		t.Fatalf("Expected version downgrade to be detected")
	}

	mismatch := mismatches[0]
	if mismatch.DeclaredVersion != "1.26.12" {
		t.Errorf("Declared version mismatch: expected 1.26.12, got %s", mismatch.DeclaredVersion)
	}
	if mismatch.ObservedVersion != "1.26.5" {
		t.Errorf("Observed version mismatch: expected 1.26.5, got %s", mismatch.ObservedVersion)
	}
	if mismatch.Severity != "critical" {
		t.Errorf("Severity should be critical for downgrade: got %s", mismatch.Severity)
	}
	if !mismatch.IsSuspicious {
		t.Errorf("Downgrade should be flagged as suspicious")
	}

	t.Logf("✓ Version downgrade detected: %s@%s → %s@%s (severity: %s)",
		mismatch.PackageName, mismatch.DeclaredVersion, mismatch.PackageName, mismatch.ObservedVersion, mismatch.Severity)
}

// TestTyposquattingDetection validates typosquatting attack detection
func TestTyposquattingDetection(t *testing.T) {
	engine := correlator.NewEngine()

	// Declared: flask@2.2.2
	engine.AddDeclaredPackage(&manifest.DeclaredPackage{
		Name:            "flask",
		DeclaredVersion: "2.2.2",
		PackageManager:  "python",
		ConstraintType:  "==",
	})

	// Observed: flak (typosquatting)
	engine.AddDeclaredPackage(&manifest.DeclaredPackage{
		Name:            "flak",
		DeclaredVersion: "2.2.2",
		PackageManager:  "python",
		ConstraintType:  "==",
	})

	// Downloaded from suspicious domain
	engine.AddHTTPEvent(&correlator.HTTPEvent{
		URL:       "https://suspicious-domain.com/packages/flak-2.2.2-py3-none-any.whl",
		Method:    "GET",
		Status:    200,
		Timestamp: time.Now().Format(time.RFC3339),
	})

	chains := engine.BuildChains()
	mismatches := engine.DetectVersionMismatches(chains)

	// Should detect typosquatting
	typosquattingFound := false
	for _, mismatch := range mismatches {
		if mismatch.PackageName == "flak" && mismatch.IsSuspicious {
			typosquattingFound = true
			if mismatch.Severity != "critical" {
				t.Errorf("Typosquatting should have critical severity: got %s", mismatch.Severity)
			}
			break
		}
	}

	if !typosquattingFound {
		t.Fatalf("Expected typosquatting to be detected for 'flak'")
	}

	t.Logf("✓ Typosquatting detected: flask → flak (severity: critical)")
}

// TestSourceSubstitutionDetection validates detection of registry substitution
func TestSourceSubstitutionDetection(t *testing.T) {
	engine := correlator.NewEngine()

	// Declared: requests@2.28.1
	engine.AddDeclaredPackage(&manifest.DeclaredPackage{
		Name:            "requests",
		DeclaredVersion: "2.28.1",
		PackageManager:  "python",
		ConstraintType:  "==",
	})

	// Downloaded from malicious registry (but correct version)
	engine.AddHTTPEvent(&correlator.HTTPEvent{
		URL:       "https://attacker-registry.com/packages/requests-2.28.1-py3-none-any.whl",
		Method:    "GET",
		Status:    200,
		Timestamp: time.Now().Format(time.RFC3339),
	})

	chains := engine.BuildChains()
	mismatches := engine.DetectVersionMismatches(chains)

	// Version matches but source is wrong
	sourceSubstitutionFound := false
	for _, mismatch := range mismatches {
		if mismatch.SourceDomain != "" && mismatch.SourceDomain != "files.pythonhosted.org" {
			sourceSubstitutionFound = true
			if mismatch.Severity != "high" {
				t.Errorf("Source substitution should have high severity: got %s", mismatch.Severity)
			}
			break
		}
	}

	if !sourceSubstitutionFound {
		t.Fatalf("Expected source substitution to be detected")
	}

	t.Logf("✓ Source substitution detected: attacker-registry.com (severity: high)")
}

// TestMissingPackageDetection validates detection of missing packages
func TestMissingPackageDetection(t *testing.T) {
	engine := correlator.NewEngine()

	// Declare two packages
	engine.AddDeclaredPackage(&manifest.DeclaredPackage{
		Name:            "cryptography",
		DeclaredVersion: "38.0.0",
		PackageManager:  "python",
		ConstraintType:  "==",
	})

	engine.AddDeclaredPackage(&manifest.DeclaredPackage{
		Name:            "cffi",
		DeclaredVersion: "1.15.0",
		PackageManager:  "python",
		ConstraintType:  "==",
	})

	// Only cffi is downloaded (cryptography missing)
	engine.AddHTTPEvent(&correlator.HTTPEvent{
		URL:       "https://files.pythonhosted.org/packages/cffi-1.15.0-cp310-cp310-linux_x86_64.whl",
		Method:    "GET",
		Status:    200,
		Timestamp: time.Now().Format(time.RFC3339),
	})

	chains := engine.BuildChains()
	mismatches := engine.DetectVersionMismatches(chains)

	// Should detect missing cryptography
	missingFound := false
	for _, mismatch := range mismatches {
		if mismatch.PackageName == "cryptography" && mismatch.ObservedVersion == "" {
			missingFound = true
			if mismatch.Severity != "high" {
				t.Errorf("Missing package should have high severity: got %s", mismatch.Severity)
			}
			if !mismatch.IsSuspicious {
				t.Errorf("Missing package should be flagged as suspicious")
			}
			break
		}
	}

	if !missingFound {
		t.Fatalf("Expected missing package 'cryptography' to be detected")
	}

	t.Logf("✓ Missing package detected: cryptography@38.0.0 (severity: high)")
}

// TestPrereleaseSuspicion validates detection of prerelease substitution
func TestPrereleaseSuspicion(t *testing.T) {
	engine := correlator.NewEngine()

	// Declared: numpy@1.23.3 (stable)
	engine.AddDeclaredPackage(&manifest.DeclaredPackage{
		Name:            "numpy",
		DeclaredVersion: "1.23.3",
		PackageManager:  "python",
		ConstraintType:  "==",
	})

	// Observed: numpy@1.24.0rc1 (prerelease)
	engine.AddHTTPEvent(&correlator.HTTPEvent{
		URL:       "https://files.pythonhosted.org/packages/numpy-1.24.0rc1-cp310-cp310-linux_x86_64.whl",
		Method:    "GET",
		Status:    200,
		Timestamp: time.Now().Format(time.RFC3339),
	})

	chains := engine.BuildChains()
	mismatches := engine.DetectVersionMismatches(chains)

	if len(mismatches) == 0 {
		t.Fatalf("Expected prerelease substitution to be detected")
	}

	mismatch := mismatches[0]
	if mismatch.ObservedVersion != "1.24.0rc1" {
		t.Errorf("Expected prerelease version 1.24.0rc1, got %s", mismatch.ObservedVersion)
	}
	if mismatch.Severity != "high" {
		t.Errorf("Prerelease substitution should have high severity: got %s", mismatch.Severity)
	}

	t.Logf("✓ Prerelease substitution detected: %s → %s (severity: high)",
		mismatch.DeclaredVersion, mismatch.ObservedVersion)
}

// TestAttackScenariosFromJSON loads and validates attack scenarios from JSON
func TestAttackScenariosFromJSON(t *testing.T) {
	scenarios := LoadAttackScenarios(t)

	if len(scenarios) == 0 {
		t.Fatalf("No attack scenarios loaded")
	}

	t.Logf("Loaded %d attack scenarios", len(scenarios))

	// Validate each scenario structure
	for i, scenario := range scenarios {
		if scenario.Scenario == "" {
			t.Errorf("Scenario %d: missing scenario name", i)
		}
		if scenario.Description == "" {
			t.Errorf("Scenario %d: missing description", i)
		}
		if scenario.Manifest == nil {
			t.Errorf("Scenario %d: missing manifest", i)
		}
		if len(scenario.Trace) == 0 {
			t.Errorf("Scenario %d: empty trace", i)
		}
		if scenario.ExpectedResult == nil {
			t.Errorf("Scenario %d: missing expected result", i)
		}

		t.Logf("  [%d] %s: %s", i+1, scenario.Scenario, scenario.Description)
	}
}

// TestCLIAnalyzeExitCodes validates CLI exit codes for various scenarios
func TestCLIAnalyzeExitCodes(t *testing.T) {
	testCases := []struct {
		name        string
		scenario    string
		strict      bool
		expectedExit int
		description string
	}{
		{
			name:        "Normal install no strict",
			scenario:    "normal_install",
			strict:      false,
			expectedExit: 0,
			description: "Should exit 0 for clean install without strict mode",
		},
		{
			name:        "Version mismatch no strict",
			scenario:    "version_mismatch",
			strict:      false,
			expectedExit: 0,
			description: "Should exit 0 for version mismatch without strict mode (warning only)",
		},
		{
			name:        "Version mismatch with strict",
			scenario:    "version_mismatch",
			strict:      true,
			expectedExit: 1,
			description: "Should exit 1 for version mismatch with --strict flag",
		},
		{
			name:        "Typosquatting attack strict",
			scenario:    "typosquatting",
			strict:      true,
			expectedExit: 2,
			description: "Should exit 2 for critical security issue (typosquatting)",
		},
		{
			name:        "Source substitution strict",
			scenario:    "source_substitution",
			strict:      true,
			expectedExit: 2,
			description: "Should exit 2 for high-risk source substitution",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			t.Logf("Testing: %s", tc.description)
			t.Logf("  Scenario: %s, Strict: %v", tc.scenario, tc.strict)
			t.Logf("  Expected exit code: %d", tc.expectedExit)

			// Mock exit code validation
			// In real implementation, this would execute the CLI command
			// and capture the exit code
		})
	}
}

// TestErrorHandling validates error handling in edge cases
func TestErrorHandling(t *testing.T) {
	testCases := []struct {
		name        string
		setup       func(*correlator.Engine)
		shouldError bool
		errorType   string
	}{
		{
			name: "Empty manifest",
			setup: func(engine *correlator.Engine) {
				// No packages added
			},
			shouldError: false,
			errorType:   "none",
		},
		{
			name: "Empty trace log",
			setup: func(engine *correlator.Engine) {
				engine.AddDeclaredPackage(&manifest.DeclaredPackage{
					Name:            "requests",
					DeclaredVersion: "2.28.1",
					PackageManager:  "python",
				})
				// No HTTP events added
			},
			shouldError: false,
			errorType:   "none",
		},
		{
			name: "Malformed version string",
			setup: func(engine *correlator.Engine) {
				engine.AddDeclaredPackage(&manifest.DeclaredPackage{
					Name:            "test-pkg",
					DeclaredVersion: "not-a-version",
					PackageManager:  "python",
				})
				engine.AddHTTPEvent(&correlator.HTTPEvent{
					URL:       "https://registry.com/test-pkg-1.0.0.whl",
					Method:    "GET",
					Status:    200,
					Timestamp: time.Now().Format(time.RFC3339),
				})
			},
			shouldError: false,
			errorType:   "none",
		},
		{
			name: "Invalid HTTP status",
			setup: func(engine *correlator.Engine) {
				engine.AddDeclaredPackage(&manifest.DeclaredPackage{
					Name:            "requests",
					DeclaredVersion: "2.28.1",
					PackageManager:  "python",
				})
				engine.AddHTTPEvent(&correlator.HTTPEvent{
					URL:       "https://registry.com/requests-2.28.1.whl",
					Method:    "GET",
					Status:    404,
					Timestamp: time.Now().Format(time.RFC3339),
				})
			},
			shouldError: false,
			errorType:   "none",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			engine := correlator.NewEngine()
			tc.setup(engine)

			chains := engine.BuildChains()
			mismatches := engine.DetectVersionMismatches(chains)

			t.Logf("Built %d chains, detected %d mismatches", len(chains), len(mismatches))

			if tc.shouldError {
				t.Errorf("Expected error of type %s", tc.errorType)
			}
		})
	}
}

// TestConstraintSatisfaction validates version constraint checking
func TestConstraintSatisfaction(t *testing.T) {
	engine := correlator.NewEngine()

	testCases := []struct {
		name              string
		declaredVersion   string
		observedVersion   string
		constraintType    string
		shouldSatisfy     bool
	}{
		{
			name:            "Exact match ==",
			declaredVersion: "1.0.0",
			observedVersion: "1.0.0",
			constraintType:  "==",
			shouldSatisfy:   true,
		},
		{
			name:            "Exact mismatch ==",
			declaredVersion: "1.0.0",
			observedVersion: "1.0.1",
			constraintType:  "==",
			shouldSatisfy:   false,
		},
		{
			name:            "Greater than >",
			declaredVersion: "1.0.0",
			observedVersion: "1.1.0",
			constraintType:  ">",
			shouldSatisfy:   true,
		},
		{
			name:            "Less than constraint <",
			declaredVersion: "2.0.0",
			observedVersion: "1.5.0",
			constraintType:  "<",
			shouldSatisfy:   true,
		},
		{
			name:            "Compatible release ~=",
			declaredVersion: "1.4.0",
			observedVersion: "1.4.5",
			constraintType:  "~=",
			shouldSatisfy:   true,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			result := engine.VersionConstraintSatisfied(
				tc.declaredVersion,
				tc.observedVersion,
				tc.constraintType,
			)

			if result != tc.shouldSatisfy {
				t.Errorf("Constraint %s %s vs %s: expected %v, got %v",
					tc.constraintType, tc.declaredVersion, tc.observedVersion,
					tc.shouldSatisfy, result)
			}

			t.Logf("✓ %s: %s %s vs %s = %v",
				tc.name, tc.declaredVersion, tc.constraintType, tc.observedVersion, result)
		})
	}
}

// BenchmarkVersionComparison benchmarks version comparison performance
func BenchmarkVersionComparison(b *testing.B) {
	engine := correlator.NewEngine()

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		engine.VersionConstraintSatisfied("1.23.3", "1.23.3", "==")
	}
}

// BenchmarkMismatchDetection benchmarks mismatch detection performance
func BenchmarkMismatchDetection(b *testing.B) {
	engine := correlator.NewEngine()

	// Setup
	for i := 0; i < 100; i++ {
		engine.AddDeclaredPackage(&manifest.DeclaredPackage{
			Name:            "pkg-" + string(rune(i)),
			DeclaredVersion: "1.0.0",
			PackageManager:  "python",
		})
	}

	for i := 0; i < 100; i++ {
		engine.AddHTTPEvent(&correlator.HTTPEvent{
			URL:       "https://registry.com/pkg-" + string(rune(i)) + "-1.0.0.whl",
			Method:    "GET",
			Status:    200,
			Timestamp: time.Now().Format(time.RFC3339),
		})
	}

	chains := engine.BuildChains()

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		engine.DetectVersionMismatches(chains)
	}
}

// BenchmarkCLIAnalyzeSimulation benchmarks end-to-end analyze command
func BenchmarkCLIAnalyzeSimulation(b *testing.B) {
	// Load test data
	manifestPath := filepath.Join("fixtures", "manifests", "requirements.txt")
	tracePath := filepath.Join("fixtures", "trace_logs", "python_install_trace.json")

	declaredPkgs, err := manifest.ParseRequirements(manifestPath)
	if err != nil {
		b.Fatalf("Failed to load manifest: %v", err)
	}

	data, err := ioutil.ReadFile(tracePath)
	if err != nil {
		b.Fatalf("Failed to load trace: %v", err)
	}

	var events []map[string]interface{}
	if err := json.Unmarshal(data, &events); err != nil {
		b.Fatalf("Failed to parse trace: %v", err)
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		engine := correlator.NewEngine()

		for _, pkg := range declaredPkgs {
			engine.AddDeclaredPackage(pkg)
		}

		for _, event := range events {
			if eventType, ok := event["event_type"].(string); ok && eventType == "http_request" {
				if url, ok := event["url"].(string); ok {
					engine.AddHTTPEvent(&correlator.HTTPEvent{
						URL:       url,
						Method:    "GET",
						Status:    200,
						Timestamp: event["timestamp"].(string),
					})
				}
			}
		}

		chains := engine.BuildChains()
		_ = engine.DetectVersionMismatches(chains)
	}
}

// TestSeverityAssignment validates severity assignment for different threat types
func TestSeverityAssignment(t *testing.T) {
	testCases := []struct {
		name             string
		threatType       string
		expectedSeverity string
	}{
		{
			name:             "Typosquatting",
			threatType:       "typosquatting",
			expectedSeverity: "critical",
		},
		{
			name:             "Version downgrade",
			threatType:       "version_downgrade",
			expectedSeverity: "critical",
		},
		{
			name:             "Source substitution",
			threatType:       "source_substitution",
			expectedSeverity: "high",
		},
		{
			name:             "Prerelease substitution",
			threatType:       "prerelease_substitution",
			expectedSeverity: "high",
		},
		{
			name:             "Missing package",
			threatType:       "missing_package",
			expectedSeverity: "high",
		},
		{
			name:             "Minor version mismatch",
			threatType:       "minor_version_mismatch",
			expectedSeverity: "low",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Map threat type to severity
			severityMap := map[string]string{
				"typosquatting":                "critical",
				"version_downgrade":           "critical",
				"source_substitution":         "high",
				"prerelease_substitution":     "high",
				"missing_package":             "high",
				"minor_version_mismatch":      "low",
			}

			actual := severityMap[tc.threatType]
			if actual != tc.expectedSeverity {
				t.Errorf("Severity mismatch for %s: expected %s, got %s",
					tc.threatType, tc.expectedSeverity, actual)
			}

			t.Logf("✓ %s: severity = %s", tc.threatType, tc.expectedSeverity)
		})
	}
}
